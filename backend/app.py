# app.py — IMIDEA APIs (Ad placement + Predictive Maintenance)
from flask import Flask, app, request, jsonify
from flask_cors import CORS
import joblib, json
import pandas as pd
import numpy as np

app = Flask(__name__)

#  CORS CONFIG 
CORS(app, resources={r"/api/*": {"origins": "*"}}, supports_credentials=True)

@app.after_request
def add_cors_headers(response):
    response.headers.add("Access-Control-Allow-Origin", "*")
    response.headers.add("Access-Control-Allow-Headers", "Content-Type,Authorization")
    response.headers.add("Access-Control-Allow-Methods", "GET,PUT,POST,DELETE,OPTIONS")
    return response

#  (A) Best Place API (Ad Intelligence)
#  • Loads trained model to suggest best ad location
#  • Validates categorical inputs against allowed values
#  • Returns best place in Arabic or English

PLACE_MODEL_PATH = "best_place_small.pkl"
place_pipe = joblib.load(PLACE_MODEL_PATH)

INPUT_COLS_BTP = [
    "business_type","campaign_goal","budget_level","campaign_duration",
    "area_type","active_hours","ad_style","interaction_goal","offer_type","business_stage"
]

ALLOWED_BTP = {
    "business_type":    ["restaurant_cafe","retail_fashion","pharmacy_health","electronics","supermarket","services"],
    "campaign_goal":    ["sales","awareness","new_customers","footfall"],
    "budget_level":     ["low","medium","high"],
    "campaign_duration":["1_week","2_weeks","1_month","3_months"],
    "area_type":        ["residential","commercial","mixed"],
    "active_hours":     ["morning","noon","evening"],
    "ad_style":         ["text","visual","interactive","video"],
    "interaction_goal": ["visit_store","visit_website","call_whatsapp","scan_qr"],
    "offer_type":       ["none","discount","bundle","new_launch"],
    "business_stage":   ["new","growing","established"],
}

PLACE_MAP_AR = {
    "malls": "المجمعات",
    "streets": "الشوارع التجارية",
    "entertainment_restaurants": "أماكن الترفيه"
}

PLACE_MAP_EN = {
    "malls": "malls",
    "streets": "streets",
    "entertainment_restaurants": "entertainment_places"
}

@app.get("/api/health")
def health():
    """Simple health-check endpoint for the Ad model."""
    return jsonify({"status": "ok", "ad_model": PLACE_MODEL_PATH})


@app.post("/api/btp")
def best_place():
    """Best Place for Ads endpoint (/api/btp)."""
    data = request.get_json(force=True) or {}
    lang = str(data.get("lang","ar")).lower()
    is_ar = (lang == "ar")

    # Required fields check
    missing = [c for c in INPUT_COLS_BTP if data.get(c) in (None,"")]
    if missing:
        msg_ar = f"حقول مفقودة: {missing}"
        msg_en = f"Missing required fields: {missing}"
        return jsonify({"error": msg_ar if is_ar else msg_en}), 400

    # Allowed values check
    for k, v in data.items():
        if k in ALLOWED_BTP and v not in ALLOWED_BTP[k]:
            msg_ar = f"قيمة غير مسموحة في الحقل '{k}': {v}"
            msg_en = f"Invalid value for '{k}': {v}"
            return jsonify({"error": msg_ar if is_ar else msg_en}), 400

    # Build model input
    X = pd.DataFrame([{c: data.get(c) for c in INPUT_COLS_BTP}])
    pred = place_pipe.predict(X)[0]
    pred_str = str(pred)

    if is_ar:
        best_place_out = PLACE_MAP_AR.get(pred_str, pred_str)
        note = "تم التنبؤ بالمكان الأنسب عبر نموذج مُدرّب على سيناريوهات منظّمة."
    else:
        best_place_out = PLACE_MAP_EN.get(pred_str, pred_str)
        note = "Prediction generated by a supervised model trained on structured scenarios."

    return jsonify({
        "best_place": best_place_out,
        "note": note,
        "debug": {"raw_pred": pred_str}
    })


#  (B) Predictive Maintenance API
#  • Loads trained CatBoost model and feature list
#  • Applies same feature engineering used in the notebook
#  • One-hot encodes and reindexes to match training columns
#  • Returns status: OK / WARN / FAIL with a short note

PM_MODEL_PATH = "final_catboost_model.pkl"
PM_FEATS_PATH = "catboost_features.json"

cb_model = joblib.load(PM_MODEL_PATH)
feature_list = json.load(open(PM_FEATS_PATH, "r"))


def fe_engineer(df: pd.DataFrame) -> pd.DataFrame:
    """Feature engineering for predictive maintenance."""
    # Age of screen in years
    if 'install_year' in df.columns:
        df['install_year'] = pd.to_numeric(df['install_year'], errors='coerce')
        df['age_years'] = (2024 - df['install_year']).clip(lower=0)

    # Physical area (m^2)
    if {'height_m','width_m'}.issubset(df.columns):
        df['height_m'] = pd.to_numeric(df['height_m'], errors='coerce')
        df['width_m']  = pd.to_numeric(df['width_m'], errors='coerce')
        df['area_m2']  = df['height_m'] * df['width_m']
    else:
        df['area_m2'] = np.nan

    # Weekly hours
    if 'daily_hours' in df.columns:
        df['daily_hours']  = pd.to_numeric(df['daily_hours'], errors='coerce')
        df['weekly_hours'] = df['daily_hours'] * 7
    else:
        df['weekly_hours'] = np.nan

    # Weekly energy consumption (Wh)
    if {'rated_power_w','weekly_hours'}.issubset(df.columns):
        df['rated_power_w'] = pd.to_numeric(df['rated_power_w'], errors='coerce')
        df['weekly_energy_Wh'] = df['rated_power_w'] * df['weekly_hours']
    else:
        df['weekly_energy_Wh'] = np.nan

    # Temperature × Humidity interaction
    if {'temperature','humidity_pct'}.issubset(df.columns):
        df['temperature']  = pd.to_numeric(df['temperature'], errors='coerce')
        df['humidity_pct'] = pd.to_numeric(df['humidity_pct'], errors='coerce')
        df['temp_x_humidity'] = df['temperature'] * (df['humidity_pct'] / 100.0)

    return df


def prepare_X(payload: dict) -> pd.DataFrame:
    """Prepare a single-row payload for the CatBoost model."""
    df = pd.DataFrame([payload]).copy()

    # Apply same feature engineering used in training
    df = fe_engineer(df)

    # Drop any target/ID columns 
    drop_cols = [c for c in ['screen_id','status','y_multi','y_bin'] if c in df.columns]
    X_all = df.drop(columns=drop_cols, errors='ignore')

    # One-hot encoding: match notebook logic 
    cat_cols = [c for c in X_all.columns if X_all[c].dtype == 'object']
    X_tab = pd.get_dummies(X_all, columns=cat_cols, drop_first=False)

    # Reindex to match feature_list from training
    X_tab = X_tab.reindex(columns=feature_list, fill_value=0)

    # Any numeric NaNs → 0 (defensive handling for runtime inputs)
    for c in X_tab.columns:
        if X_tab[c].dtype.kind in "if":
            X_tab[c] = pd.to_numeric(X_tab[c], errors='coerce').fillna(0)

    return X_tab


AR_STATUS = {"OK": "سليمة", "WARN": "تنبيه", "FAIL": "عطل"}


@app.post("/api/pm_predict")
def pm_predict():
    data = request.get_json(force=True) or {}
    lang = str(data.get("lang","ar")).lower()
    is_ar = (lang == "ar")

    # Prepare features
    try:
        X = prepare_X(data)
    except Exception as e:
        msg = "خطأ في معالجة البيانات المدخلة." if is_ar else "Input processing error."
        return jsonify({"error": msg, "detail": str(e)}), 400

    # Prediction
    try:
        pred = cb_model.predict(X)[0]   # 'OK' | 'WARN' | 'FAIL'
        pred = str(pred)
    except Exception as e:
        msg = "تعذّر إجراء التنبؤ." if is_ar else "Prediction failed."
        return jsonify({"error": msg, "detail": str(e)}), 500

    # Localized status + note
    if is_ar:
        status_out = AR_STATUS.get(pred, pred)
        note = "تم التقدير بناءً على خصائص الشاشة وبيئة التشغيل المُدخلة."
    else:
        status_out = pred
        note = "Estimated from provided screen specs and environment."

    return jsonify({
        "status": status_out,
        "note": note,
        "debug": {"raw_pred": pred}
    })

# run the API locally on port 8000
if __name__ == "__main__":
    print(">>> IMIDEA APIs running at http://127.0.0.1:8000")
    app.run(host="127.0.0.1", port=8000, debug=True)